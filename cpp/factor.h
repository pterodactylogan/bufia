#ifndef FACTOR_H
#define FACTOR_H

#include <list>
#include <set>
#include <string>
#include <unordered_map>
#include <vector>

using ::std::list;
using ::std::set;
using ::std::vector;

class Factor {
public:
	vector<vector<char>> bundles;

	Factor(vector<vector<char>> b) {
		bundles = b;
	}

	Factor(int width, int num_features) {
		bundles = vector<vector<char>>(width, vector<char>(num_features));
	}

	Factor(){}

	// Strict total order between factors for sorting purposes. 
	// Here, + > - > 0 > * > #
	bool operator < (const Factor& other) const;

	bool operator > (const Factor& other) const;

	int size() const;

	// Returns true if this Factor is a parent of `child`, false otherwise.
	bool generates(const Factor& child, int order = 1) const;

	// Returns a list of factors each one degree more specific than this Factor.
	// Features are ordered so that any given Factor can only be generated by one
	// path.
	list<Factor> getNextFactors(
		const std::unordered_map<std::string, Factor>& alphabet, 
		int max_width, int max_features, int max_dist = -1,
		vector<std::pair<int, char>>* feature_ranks = nullptr) const;

	// Returns a string displaying Factor contents. For debugging.
	std::string toString() const;

	// Concat with other Factor. Do not append a factor to itself.
	void append(const Factor& other);

	set<Factor> getSubsequences(int width = 1) const;
};

#endif /* FACTOR_H */
